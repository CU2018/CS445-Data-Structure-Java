/**   A class of bags whose entries are stored in a chain of linked nodes.	The bag is never full.   @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public final class LinkedBag<T> implements BagInterface<T>{	private Node firstNode;       // Reference to first node	private int numberOfEntries;	public LinkedBag()	{		firstNode = null;      	numberOfEntries = 0;	} // end default constructor	/** Sees whether this bag is empty.	    @return  True if this bag is empty, or false if not. */	public boolean isEmpty() 	{		return numberOfEntries == 0;	} // end isEmpty	/** Gets the capacity of this bag.	    @return  The integer number of entries that this bag can hold. */	public int getCapacity() 	{		return Integer.MAX_VALUE;	} // end getCapacity	/** Gets the number of entries currently in this bag.	    @return  The integer number of entries currently in this bag. */	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	/** Adds a new entry to this bag.	    @param newEntry  The object to be added as a new entry	    @return  True if the addition is successful, or false if not. */	public boolean add(T newEntry)  	      // OutOfMemoryError possible	{		//Add to beginning of chain:		Node newNode = new Node(newEntry);		newNode.next = firstNode; //Make new node reference rest of chain		                           // (firstNode is null if chain is empty)		firstNode = newNode;      // New node is at beginning of chain, add to the front		numberOfEntries++;		return true;	} // end add	/** Retrieves all entries that are in this bag.	    @return  A newly allocated array of all the entries in this bag. */	public T[] toArray()	{		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] result = (T[])new Object[numberOfEntries]; //Unchecked cast		int index = 0;		Node currentNode = firstNode;		while (index < numberOfEntries && (currentNode != null))		{			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		} // end while		return result;	} // end toArray	/** Counts the number of times a given entry appears in this bag.		 @param anEntry  The entry to be counted.		 @return  The number of times anEntry appears in this bag. */	public int getFrequencyOf(T anEntry) 	{		int frequency = 0;		int counter = 0;		Node currentNode = firstNode;		while ((counter < numberOfEntries) && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				frequency++;			counter++;			currentNode = currentNode.next;		}		return  frequency;	} // end getFrequencyOf	/** Tests whether this bag contains a given entry.		 @param anEntry  The entry to locate.		 @return  True if the bag contains anEntry, or false otherwise. */	public boolean contains(T anEntry)	{		boolean found = false;		Node currentNode = firstNode;		while (!found && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		}		return found;   } // end contains    	// Locates a given entry within this bag.	// Returns a reference to the node containing the entry, if located,	// or null otherwise.	private Node getReferenceTo(T anEntry)	{		boolean found = false;		Node currentNode = firstNode;		while (!found && (currentNode != null))		{			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		}     		return currentNode;	} // end getReferenceTo   /** Removes all entries from this bag. */	public void clear() 	{		while (!isEmpty())			remove();	} // end clear		/** Removes one unspecified entry from this bag, if possible.       @return  Either the removed entry, if the removal                was successful, or null. */	public T remove()	{		T result = null;		if (firstNode != null)		{			result = firstNode.data;			firstNode = firstNode.next; //Remove first node from chain			numberOfEntries--;		}		return result;	} // end remove		/** Removes one occurrence of a given entry from this bag, if possible.       @param anEntry  The entry to be removed.       @return  True if the removal was successful, or false otherwise. */   public boolean remove(T anEntry) 	{		boolean result = false;		Node nodeN = getReferenceTo(anEntry);		if (nodeN != null) //we get a null return from "getReferenceTo()" method if anEntry			// is not found in the list (the end reference portion of the list is null)		{			nodeN.data = firstNode.data;			firstNode = firstNode.next;			numberOfEntries--;			result = true;		}		return result;	} // end remove	private class Node	{		private T data; //Entry in bag		private Node next; //Link to next node	 	private Node(T dataPortion)		{			this(dataPortion, null);		} // end constructor		private Node(T dataPortion, Node nextNode)		{			data = dataPortion;			next = nextNode;		} // end constructor	} // end Node	/** Creates a new bag that combines the contents of this bag and anotherBag.	 @param anotherBag  The bag that is to be added.	 @return  A combined bag. */	public BagInterface<T> union(BagInterface<T> anotherBag)	{		BagInterface<T> newBag = new LinkedBag<T>();		int index = 0;		Node currentNode = firstNode;		while (index < this.numberOfEntries)		{			newBag.add(currentNode.data);			index++;			currentNode = currentNode.next;		}		T[] anotherBagArray = anotherBag.toArray(); //如果两个都用toArray()，cost会更多，我们可以直接访问thisBag的data		                                          // 所以用while loop循环第一个，第二个用toArray()		for (T item : anotherBagArray)			newBag.add(item);		return newBag;	}	/** Creates a new bag that contains those objects that occur	 in both this bag and anotherBag.	 @param anotherBag  The bag that is to be compared.	 @return  A combined bag. */	public BagInterface<T> intersection(BagInterface<T> anotherBag)	{		BagInterface<T> newBag = new LinkedBag<T>();		int index = 0;		Node currentNode = firstNode;		while (index < this.numberOfEntries)		{			if (anotherBag.contains(currentNode.data))				newBag.add(currentNode.data);			index++;			currentNode = currentNode.next;		}		return newBag;	}	/** Creates a new bag of objects that would be left in this bag	 after removing those that also occur in anotherBag.	 @param anotherBag  The bag that is to be removed.	 @return  A combined bag. */	public BagInterface<T> difference(BagInterface<T> anotherBag)	{		BagInterface<T> newBag = new LinkedBag<T>();		int index = 0;		Node currentNode = firstNode;		while (index < this.numberOfEntries)		{			int thisFrequency = this.getFrequencyOf(currentNode.data); //此数据在thisBag里面出现的次数			int anotherFrequency = anotherBag.getFrequencyOf(currentNode.data); //此数据在anotherBag里面出现的次数			if ((thisFrequency > anotherFrequency) && !newBag.contains(currentNode.data))			{      //只有在thisBag里面出现的次数大于anotherBag里面出现的次数，并且newBag里面不包含此元素，才add进newBag两个次数的差值				for (int i = thisFrequency - anotherFrequency; i > 0 ; i--) //比如Bag1 = {5,1,1,6,7};Bag2 = {1,6},那么Bag1.difference(Bag2) = {5,1,7}				{					newBag.add(currentNode.data); //这样可以把同一元素thisBag中多于anotherBag一次性加入到newBag里面				}			}			index++;			currentNode = currentNode.next;		}		return newBag;	}} // end LinkedBag